#!/usr/bin/env python
import json
import socket
import os
import sys
import errno
import optparse
import random
import string
import time

## Utility functions

def mkpath(path):
    try: os.makedirs(path)
    except OSError as exc:
        if exc.errno == errno.EEXIST: pass
        else: raise

def random_string(length):
    rng = random.SystemRandom()
    alphabet = string.letters[0:52] + string.digits
    return "".join(rng.choice(alphabet) for _ in range(length))

def pid_exists(pid):
    try: os.kill(pid, 0)
    except OSError: return False
    else: return True

def read_pid(filepath):
    try: return int(open(filepath).read().strip())
    except IOError: return None

def try_connect(sock, address, timeout = 15):
    end_time = time.time() + timeout
    while time.time() < end_time:
        exception = None
        try: sock.connect(address)
        except Exception, e: exception = e
        else: break
        time.sleep(0.5)
    if exception: raise exception

## Make sure config file exists

config_dir = os.path.join(os.environ['HOME'], ".clj")
mkpath(config_dir)

config_file = os.path.join(config_dir, "config.json")

if not os.path.exists(config_file):
    fd = os.open(config_file, os.O_WRONLY & os.O_CREAT, 0600)
    f  = os.fdopen(fd)
    json.dump({"password": random_string(32)}, f)
    f.close()

## Start server process if it doesn't already exist

server_jar = "clj-daemon-1.0.0-SNAPSHOT-standalone.jar"

pid_file   = os.path.join(config_dir, "daemon.pid")
server_pid = read_pid(pid_file)

if not server_pid or not pid_exists(server_pid):
    server_pid = os.fork()
    if server_pid > 0:
        open(pid_file, "w").write(str(server_pid))
    else:
        sys.stdin.close()
        sys.stdout.close()
        sys.stderr.close()
        os.execlp("java", "java", "-jar", server_jar, config_file)

## Parse options from command-line

parser = optparse.OptionParser()
parser.add_option(
    "-e", "--eval", dest="source",
    help="evaluate the Clojure FORM", metavar="FORM")
parser.add_option(
    "-c", "--classpath", dest="classpath",
    help="use the supplied CLASSPATH", metavar="CLASSPATH")

(opts, args) = parser.parse_args()

classpath = ["file://" + os.path.abspath(p) for p in opts.classpath.split(':')]

## Send commands to server

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
try_connect(sock, ('localhost', 8000))

sock.send(json.dumps({"classpath": classpath}))
sock.send(json.dumps({"source": opts.source}))

data = json.loads(sock.recv(1024))

sock.close()

print data['return']
